### 分库分表是什么    
可以这样定义分库分表：当业务的增长导致数据库瓶颈的时候，一种解决瓶颈的手段。数据库是很容易出现瓶颈的一个地方，瓶颈包含性能、容量等等，分库分表是大多数互联网公司遇到数据库瓶颈后，解决瓶颈的近乎行业标准手段。    

分表解决的是，过大的数据表影响查询速度的问题，比如单表上亿，那么拆成10个表，查询起来会比一个表更快；    
分库更多解决的是机器的局限问题，单机容量有限，这是由机器硬件决定的，比如我的网卡打满，CPU打满，磁盘写满，这些场景必须将计算分布到其它机器解决，先拆分进程，再将进程拆分到不同的机器上。    

分库分表的核心是为了创建一个对业务相对透明的逻辑大表，隔离存储的负载度，进而实现在业务眼里的无限存储。    

### 如何保障索引    
当存储分布式以后，单机的索引是无法满足业务对索引的要求的，而SQL是对索引更上一层楼的封装，这个部分会有一定程度的限制，比如join这种操作就无法实现。    

一般解决方法是，简单的索引逻辑靠中间件构建虚拟索引，复杂索引靠其它方式构建外置索引。    

所有的分库分表的中间件工作，无非是在数据源和应用之间封装一层虚拟的满足基本需要的索引，应用发送请求到中间件，中间件起到一部分索引的作用，判定需要到哪个库，哪个表来执行。中间件还有一个所用是，对涉及逻辑表的部分，进行一部分SQL逻辑改写，来最终判定到某些部分执行。    

水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的订单等；禁止不带切分的维度的查询，及时中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询。    
对于更复杂的查询要求，应用方需要单独构建另外的索引，即把索引单独拆出来做成一个系统，来满足检索需求。作为代价，外置的索引会比内置的索引相对慢些。    

### 事务    
因为分库分表把需要操作的数据源分散了，所以核心问题是如何保障跨数据库、跨进程、跨机器的操作原子性。    

对于那些对性能要求很高，但对一致性要求并不高的系统，往往并不苛求系统的实时一致性，只要在一个允许的时间周期内达到最终一致性即可。    

> 大事务 = 小事务 + MQ    

通过MQ实现的数据一致性，相当于把动作归结为最终状态。    








