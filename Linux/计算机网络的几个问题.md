# 一、TCP三次握手
**通俗理解：**

![](https://github.com/huhuics/Accumulate/blob/master/image/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

为什么一定要进行三次握手来保证双工连接？一次不行吗？两次不行吗？下面举一个通俗的例子来理解。

**第一次对话：**

老婆让甲去打酱油，半路碰到一个朋友乙，甲问了一句：哥们你吃饭了吗？

结果乙戴耳机听歌没反应，甲心里想：跟你说话也没个回音，不和你说了。沟通失败。

如果乙听到甲说话，那么第一次对话成功，接下来进行第二次对话。

**第二次对话：**

乙听到甲说的话，但乙是老外，不理解甲的意思不知道怎么回答，于是随便回答一句学过的中文：我去厕所。甲理解为“去厕所吃饭”，道不同不相为谋，离你远点吧，沟通失败。说明乙无法做出正确应答的情况下沟通失败。

**第三次对话：**

甲刚和乙打完招呼，突然老婆喊他：“打个酱油怎么这么慢？”，甲是个妻管严，听完话吓得二话不说赶紧跑回家，把乙晾在一边。乙心想：这什么人啊，得了，我也回家。沟通失败，说明甲无法做出应答的情况下沟通失败。

如果甲也做出了正确的应答：我也吃了，那么第三次对话成功，两人建立起顺畅的沟通渠道，接下来持续聊天。

第三次对话是为了防止乙一直等待而浪费自己的时间，而不是为了保证甲能够正确回应乙的信息。

**为什么要三次握手**

> 在谢希仁著《计算机网络》中讲三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到服务端，因而产生错误”。考虑这样一种情况：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间滞留了，以至延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就想client发出确认报文段同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的连接已经建立并一直等待client发来数据。这样，server的很多资源会白白浪费。采用三次握手可以避免上述情况的发生。例如上面这种情况，client不会向server的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。

> 这个问题的本质是，信道不可靠。但是通信双方要建立通信，三次通信是理论上的最小值。因此三次握手不是TCP本身的要求，而是为了满足在不可靠信道上进行可靠地传输信息的需求所导致的。三次握手达到了，那后面你想接着握手也好，发数据也好，跟进行可靠信息传输的需求就没关系了。如果信道是可靠的，那无论什么时候发消息，对方一定能收到。

**实例**

client > server : Sequence Num 836

server > client : Sequence Num 486, ACK Num 837

client > server : ACK Num 487, ack 1

第一次握手：client发送syn=1，随机产生seq num=836的数据包到server，server由syn=1知道client要求建立连接

第二次握手：server收到连接请求后，向client发送ack number=837，syn=1，ack=1，seq num= 486的包

第三次握手：client收到后检查ack number是否正确，即第一次发送的seq number + 1，以及位码ack是否为1，若正确，client会再发送ack number=487，ack=1。server收到后确认ack number = seq num + 1, ack=1则连接建立成功

# 二、HTTP连接
HTTP是建立在TCP协议（传输层）之上的一种应用层协议，HTTP最显著的特点是客户端发送的每次请求都需要服务器回送响应，请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序在线状态，需要不断向服务器发起连接请求，服务器在收到该请求后进行回复，表明知道客户端在线。

若服务器长时间无法收到客户端的请求，则认为客户端已下线；若客户端长时间无法收到服务器的回复，则认为网络已经断开。

# 三、Socket概念
Socket是通信的基石，是支持TCP/IP协议的网络通信的基本单元。Socket是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：

+ 连接使用的协议

+ 本地主机IP地址

+ 本地进程的协议端口

+ 远程主机的IP地址

+ 远程主机进程的协议端口






